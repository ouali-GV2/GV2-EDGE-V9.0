"""
ACCELERATION ENGINE V8 - Anticipatory Detection
=================================================

Core V8 module that replaces V7's reactive detection with anticipatory signals.

V7 Problem (P5 CRITICAL from REVIEW):
- momentum = abs(price_change) → instantaneous, no derivative
- volume = ratio vs average → static threshold, no acceleration
- System detects stocks that ALREADY MOVED, not ABOUT TO MOVE

V8 Solution:
- Tracks velocity (1st derivative) AND acceleration (2nd derivative)
- Uses z-scores vs 20-day baseline instead of absolute thresholds
- Introduces ACCUMULATING state: volume accelerating + price stable
  → This is the earliest detectable signal before a breakout
- Produces AccelerationSignal that integrates into MonsterScore V4

Detection Pipeline:
  TickerStateBuffer (data) → AccelerationEngine (analysis) → SmallCapRadar (scoring)

Key Insight:
  Most top gainers show 3-15 minutes of unusual volume BEFORE the price moves.
  An ACCUMULATING state with volume z-score >2.0 and stable price is the
  highest-probability early entry signal for small-cap breakouts.
"""

import asyncio
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Set, Tuple
import logging

from src.engines.ticker_state_buffer import (
    TickerStateBuffer,
    DerivativeState,
    BaselineStats,
    get_ticker_state_buffer,
)

logger = logging.getLogger(__name__)


# ============================================================================
# Configuration
# ============================================================================

# Acceleration signal thresholds (V8: z-score based, NOT absolute)
VOLUME_ACCEL_ZSCORE_THRESHOLD = 1.5    # Volume z-score for "interesting"
VOLUME_ACCEL_ZSCORE_STRONG = 2.5       # Volume z-score for "strong signal"
PRICE_STABILITY_MAX_PCT = 0.02         # Max price change for "stable" (2%)
ACCUMULATION_MIN_SCORE = 0.30          # Min accumulation score to flag
BREAKOUT_READINESS_THRESHOLD = 0.50    # Min readiness for launch alert

# State transition thresholds
TRANSITION_ACCUMULATING_TO_LAUNCHING = 0.60  # Readiness needed
TRANSITION_LAUNCHING_TO_BREAKOUT = 0.80

# Alert cooldown (prevent spam)
ALERT_COOLDOWN_SECONDS = 120  # 2 min between alerts for same ticker


# ============================================================================
# Data Classes
# ============================================================================

@dataclass
class AccelerationAlert:
    """Alert generated by AccelerationEngine."""
    ticker: str
    timestamp: datetime
    alert_type: str           # ACCUMULATING, PRE_LAUNCH, LAUNCHING, BREAKOUT
    confidence: float         # 0-1

    # Derivative data
    derivative_state: DerivativeState

    # Context
    volume_zscore: float = 0.0
    price_zscore: float = 0.0
    accumulation_score: float = 0.0
    breakout_readiness: float = 0.0

    # Recommended action
    urgency: str = "LOW"      # LOW, MEDIUM, HIGH, CRITICAL
    message: str = ""

    def to_dict(self) -> Dict:
        return {
            "ticker": self.ticker,
            "timestamp": self.timestamp.isoformat(),
            "alert_type": self.alert_type,
            "confidence": round(self.confidence, 3),
            "volume_zscore": round(self.volume_zscore, 2),
            "price_zscore": round(self.price_zscore, 2),
            "accumulation_score": round(self.accumulation_score, 3),
            "breakout_readiness": round(self.breakout_readiness, 3),
            "urgency": self.urgency,
            "message": self.message,
            "state": self.derivative_state.state,
        }


@dataclass
class AccelerationScore:
    """
    Acceleration score for integration into MonsterScore V4.

    This replaces the V7 static momentum component with a dynamic,
    derivative-based score that captures the RATE OF CHANGE.
    """
    # Core scores (0-1)
    acceleration_score: float = 0.0     # Main score for MonsterScore
    accumulation_score: float = 0.0     # Sub-score: accumulation detection
    breakout_readiness: float = 0.0     # Sub-score: how close to breakout

    # State
    state: str = "DORMANT"

    # Z-scores
    volume_zscore: float = 0.0
    price_zscore: float = 0.0

    # Confidence
    confidence: float = 0.0
    samples: int = 0

    def get_monster_score_boost(self) -> float:
        """
        Get additive boost for MonsterScore.

        ACCUMULATING: +0.05 to +0.12 (early detection bonus)
        LAUNCHING: +0.08 to +0.15
        BREAKOUT: +0.10 to +0.18
        DORMANT/EXHAUSTED: 0
        """
        if self.state == "DORMANT":
            return 0.0
        if self.state == "EXHAUSTED":
            return -0.05  # Penalty for exhausted moves

        # Base boost by state
        state_boosts = {
            "ACCUMULATING": 0.05,
            "LAUNCHING": 0.08,
            "BREAKOUT": 0.10,
        }
        base = state_boosts.get(self.state, 0.0)

        # Scale by confidence and score
        scaled = base + (self.acceleration_score * 0.08)

        return min(0.18, scaled * self.confidence)


# ============================================================================
# Acceleration Engine
# ============================================================================

class AccelerationEngine:
    """
    V8 Anticipatory Detection Engine.

    Consumes TickerStateBuffer data and produces:
    1. AccelerationAlerts (real-time notifications)
    2. AccelerationScores (for MonsterScore integration)

    Usage:
        engine = AccelerationEngine()

        # Score a ticker
        score = engine.score(ticker)
        boost = score.get_monster_score_boost()

        # Scan all tracked tickers
        alerts = engine.scan_all()

        # Register for alerts
        engine.on_alert(lambda alert: print(alert))
    """

    def __init__(self, buffer: Optional[TickerStateBuffer] = None):
        self._buffer = buffer or get_ticker_state_buffer()

        # Alert tracking
        self._last_alerts: Dict[str, datetime] = {}
        self._alert_callbacks: list = []

        # Stats
        self._alerts_generated = 0
        self._scans_completed = 0

    def on_alert(self, callback) -> None:
        """Register callback for acceleration alerts."""
        self._alert_callbacks.append(callback)

    def score(self, ticker: str) -> AccelerationScore:
        """
        Compute acceleration score for a ticker.

        Returns AccelerationScore for integration into MonsterScore.
        """
        ticker = ticker.upper()
        ds = self._buffer.get_derivative_state(ticker)

        if ds.samples < 3 or ds.confidence < 0.2:
            return AccelerationScore(state="DORMANT", confidence=0.0, samples=ds.samples)

        # Compute composite acceleration score
        # Weighted combination of derivative metrics
        accel_score = self._compute_acceleration_score(ds)

        return AccelerationScore(
            acceleration_score=accel_score,
            accumulation_score=ds.accumulation_score,
            breakout_readiness=ds.breakout_readiness,
            state=ds.state,
            volume_zscore=ds.volume_zscore,
            price_zscore=ds.price_zscore,
            confidence=ds.confidence,
            samples=ds.samples
        )

    def scan_all(self) -> List[AccelerationAlert]:
        """
        Scan all tracked tickers for acceleration signals.

        Returns list of alerts for tickers showing unusual activity.
        """
        alerts = []
        tickers = self._buffer.get_tracked_tickers()
        now = datetime.utcnow()

        for ticker in tickers:
            # Cooldown check
            last = self._last_alerts.get(ticker)
            if last and (now - last).total_seconds() < ALERT_COOLDOWN_SECONDS:
                continue

            ds = self._buffer.get_derivative_state(ticker)

            if ds.samples < 5 or ds.confidence < 0.3:
                continue

            alert = self._evaluate_for_alert(ticker, ds, now)
            if alert:
                alerts.append(alert)
                self._last_alerts[ticker] = now
                self._alerts_generated += 1

                # Notify callbacks
                for cb in self._alert_callbacks:
                    try:
                        cb(alert)
                    except Exception as e:
                        logger.error(f"Alert callback error: {e}")

        self._scans_completed += 1
        return alerts

    def get_top_movers(self, n: int = 10) -> List[Tuple[str, AccelerationScore]]:
        """Get top N tickers by acceleration score."""
        scored = []
        for ticker in self._buffer.get_tracked_tickers():
            score = self.score(ticker)
            if score.acceleration_score > 0.1 and score.state != "DORMANT":
                scored.append((ticker, score))

        scored.sort(key=lambda x: x[1].acceleration_score, reverse=True)
        return scored[:n]

    def get_accumulating(self) -> List[Tuple[str, AccelerationScore]]:
        """
        Get tickers in ACCUMULATING state.

        This is the KEY V8 feature: detecting stocks where volume is
        accelerating but price hasn't moved yet. These are the highest
        probability early entries.
        """
        result = []
        for ticker in self._buffer.get_tracked_tickers():
            score = self.score(ticker)
            if score.state == "ACCUMULATING" and score.accumulation_score >= ACCUMULATION_MIN_SCORE:
                result.append((ticker, score))

        result.sort(key=lambda x: x[1].accumulation_score, reverse=True)
        return result

    def get_stats(self) -> Dict:
        """Get engine statistics."""
        return {
            "tracked_tickers": len(self._buffer.get_tracked_tickers()),
            "alerts_generated": self._alerts_generated,
            "scans_completed": self._scans_completed,
            "buffer_stats": self._buffer.get_buffer_stats(),
        }

    # ========================================================================
    # Internal methods
    # ========================================================================

    def _compute_acceleration_score(self, ds: DerivativeState) -> float:
        """
        Compute composite acceleration score (0-1).

        Weights:
        - Volume acceleration (z-score): 40% (strongest predictor)
        - Accumulation detection: 25% (early signal)
        - Breakout readiness: 20% (how close to move)
        - Spread tightening: 15% (institutional activity indicator)
        """
        # Volume component (0-1 from z-score)
        vol_component = min(1.0, max(0.0, ds.volume_zscore / 4.0))

        # Accumulation component
        acc_component = ds.accumulation_score

        # Readiness component
        ready_component = ds.breakout_readiness

        # Spread component
        spread_component = 0.0
        if ds.spread_tightening:
            spread_component = min(1.0, abs(ds.spread_zscore) / 2.0)

        # Weighted combination
        score = (
            0.40 * vol_component +
            0.25 * acc_component +
            0.20 * ready_component +
            0.15 * spread_component
        )

        return min(1.0, max(0.0, score))

    def _evaluate_for_alert(
        self,
        ticker: str,
        ds: DerivativeState,
        now: datetime
    ) -> Optional[AccelerationAlert]:
        """Evaluate if a ticker warrants an alert."""

        # ACCUMULATING: Volume anomaly with stable price
        if ds.state == "ACCUMULATING" and ds.accumulation_score >= ACCUMULATION_MIN_SCORE:
            return AccelerationAlert(
                ticker=ticker,
                timestamp=now,
                alert_type="ACCUMULATING",
                confidence=ds.confidence * ds.accumulation_score,
                derivative_state=ds,
                volume_zscore=ds.volume_zscore,
                price_zscore=ds.price_zscore,
                accumulation_score=ds.accumulation_score,
                breakout_readiness=ds.breakout_readiness,
                urgency="MEDIUM",
                message=(
                    f"Volume accumulating (z={ds.volume_zscore:.1f}) "
                    f"with stable price. Accumulation score: {ds.accumulation_score:.2f}"
                )
            )

        # LAUNCHING: Breakout beginning
        if ds.state == "LAUNCHING":
            return AccelerationAlert(
                ticker=ticker,
                timestamp=now,
                alert_type="PRE_LAUNCH",
                confidence=ds.confidence * ds.breakout_readiness,
                derivative_state=ds,
                volume_zscore=ds.volume_zscore,
                price_zscore=ds.price_zscore,
                accumulation_score=ds.accumulation_score,
                breakout_readiness=ds.breakout_readiness,
                urgency="HIGH",
                message=(
                    f"Pre-launch detected! Price velocity: {ds.price_velocity_pct:.3%}/min, "
                    f"Vol z={ds.volume_zscore:.1f}. Readiness: {ds.breakout_readiness:.2f}"
                )
            )

        # BREAKOUT: Clear breakout
        if ds.state == "BREAKOUT":
            return AccelerationAlert(
                ticker=ticker,
                timestamp=now,
                alert_type="BREAKOUT",
                confidence=min(1.0, ds.confidence * 1.2),
                derivative_state=ds,
                volume_zscore=ds.volume_zscore,
                price_zscore=ds.price_zscore,
                accumulation_score=ds.accumulation_score,
                breakout_readiness=ds.breakout_readiness,
                urgency="CRITICAL",
                message=(
                    f"BREAKOUT! Price z={ds.price_zscore:.1f}, "
                    f"Vol z={ds.volume_zscore:.1f}. "
                    f"Velocity: {ds.price_velocity_pct:.3%}/min"
                )
            )

        return None


# ============================================================================
# Singleton
# ============================================================================

_engine_instance: Optional[AccelerationEngine] = None


def get_acceleration_engine() -> AccelerationEngine:
    """Get singleton AccelerationEngine instance."""
    global _engine_instance
    if _engine_instance is None:
        _engine_instance = AccelerationEngine()
    return _engine_instance
